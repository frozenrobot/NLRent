# Project Report

_Group 40_

Firstly let us start off by giving a small overview of our team and the efforts we put into
the project. We formed the team based on the decision that we were going to use
Django to build our web application. Two of us had former experience with it and one
person was familiar with Python and willing to acquaint themself with Django. For the
first milestone we had several meetings in which we figured out what was required, the
tools we would use to produce the specification and the content itself. We divided the
work equally between the 6 functionalities mentioned in the project description under
M1. After that, the work was split so that Khanak would implement the backend, and
Aidan and Julius would do the frontend.

**Backend:**

At first we went down the wrong path and designed the app with the Django web
development framework, but soon corrected it to use the Django REST Framework.
This was new to us, and proved to be a steep learning curve. We managed to
implement all the required functionalities in time for M2, but did not yet have the content
negotiation aspect wherein users can choose between application/json (default) and
text/csv as the content type. In functionality points 4 and 5, we also did not have N as
an optional parameter, rather it was required. Furthermore, the extra features were not
implemented yet. All these issues were fixed before the submission of M3.

The CSV representations were accounted for by adding an extra optional query
parameter ‘csv=true’, which when specified would return a CSV file containing the
response data. When omitted or set to false, the default return type would be JSON.
The CSV was generated by python string manipulation in the appropriate views and
also as a method of the Property object serializer. To make N an optional parameter, we
defined 2 separate views for when N was and wasn’t provided. The default value was
set to 10 as required, this introduced some redundancy in the code but it worked
functionality-wise.

In terms of extra features, we added an endpoint under the url properties/extra/ with
query parameters lat and long which displayed extra information about properties based
on their latitude and longitude coordinates. This information includes the plusCode
(useful to identify locations that e.g. do not have an address, it can be used to e.g.
receive deliveries) (e.g. 9F4636PX+XF), the principal subdivision (e.g. South Holland),
the principal subdivision code (e.g. NL-ZH) and the locality (e.g. Westduinpark &
Wapendal). The free client-side reverse geocoding api from api.bigdatacloud.net was
used as a 3rd party API (meeting the 2nd requirement in extra features) to provide the
information displayed by the aforementioned endpoint. It’s implementation can be found
in the ‘extra’ view in views.py. For the last additional requirement, here are the major
design and implementation decisions and the rationales behind them.

1. Switching to using PATCH instead of PUT for update operations: PATCH allows
    users to only send in the fields they want to update, and the remaining fields
    automatically retain their original values. PUT, on the other hand, required users
    to send in the entire resource again. Therefore it was easier from a user’s
    perspective to use the PATCH method for updating properties.
2. Clubbing the GET, PATCH and DELETE methods into a single view for
    functionalities 1 and 2 under M1 in the project description: Initially we were using
    different urls for each different method, and this involved using CRUD verbs in url
    names (e.g. update-property), which violates the best practices according to
    Masse’s book. Therefore we instead merged the three operations into a single url
    coupled with GET, PATCH or DELETE requests. This also avoided cluttering of
    urls, which was something we received feedback on in our M2 submission. The
    api specification was again updated to incorporate these changes.
    (More best practises: We used lowercase letters in urls to improve readability,
    and used plurals when appropriate)
3. Using the reverse geocoding api from api.bigdatacloud.net as our extra feature:
    We first considered using a static maps api, which would be able to provide a
    visual representation of the location of a property based on its longitude and
    latitude. We also considered a forward geocoding api, which would translate
    latitude and longitude coordinates into address values. However, all 3rd party
    APIs providing these features required us to register and provide billing
    information in order for the API key to work, even to use the free tier. We didn’t
    want to provide the key in our project after this, so we landed on our current
    choice as it was the only API we could access without a key. It provides useful
    information about pluscode, locality etc (discussed above) and it is accessed in
    the same manner as any other 3rd party API (providing a backend of sufficient
    complexity), so we figured it would suffice.
4. Extra query parameter for csv return type: This would avoid the need to have
    separate routes defined for json vs csv representations, rather the query
    parameter csv=true could just be included/excluded to give the desired results.
5. It is advised to use safe and idempotent methods where possible, but in our
    project we have used POST rather than PUT for create operations. The rationale
    behind this is that if we used PUT to create properties, if an externalId of a 
    pre-existing property was specified in the PUT request, the pre-existing property 
    would be overwritten with this new property, and we did not want to allow this 
    functionality. We could implement a check mechanism to ensure that externalIds
    should be unique for all properties, but this would result in the same functionality 
    as POST provides (also including check mechanism), without the idempotency benefits 
    of PUT. It is only in the create property endpoint that the POST method is used for 
    this reason; for update operations we have used the idempotent form of PATCH.

**Frontend:**

For the frontend we decided to serve static files as a single page application (SPA).
Considering how ambitious making an SPA is, it was in hindsight a cause for a lot of
unnecessary overhead when we could have just made the frontend serve some static
html, css and javascript without all the fancy functionality that an SPA brings. But eager
(and probably very stubborn) as we were, we decided to take on the challenge.
We decided on using the React library as we had heard the words Django, REST api
and React used together quite often and were curious to see how we would fare. React
is officially a library of modules, not a framework, where new modules can easily be
installed using “npm install”, similarly to how python uses “pip install”. For every
component we made a standalone class in its own File.js, the main App.js would then
go on to reference all of these components accordingly. A relatively new feature in
React is known as Hooks, which can be used for a great handful of things and we
ended up implementing this feature to carry over state from the property search page to
the update property page.

To facilitate usage of all the api methods and to make our website more navigable, we
split our website into 3 main parts:

● a create page to create new properties
● a search page to search for properties and related data by different parameters
● an update page accessible through the resulting property displays on the search
page

As a bonus we made a small home page with a welcome message and a delete
confirmation page accessible similarly to how the update page is. With this design we
dumbed down on the amount of pages we would need to implement all of our api
methods, we think this made our website more clear and straight to the point.

(view raw version of the file for this paragraph)
As functionality grew, we found more and more ways to reduce html tags and instead
use interactive react tools like “fetch” to replace the html <form> tag and “Button” to
replace the <input type=”submit> tag. As hinted at earlier, this turned out to take up a lot
of time, which we somewhat made up for by easing the use of strict design patterns in
our project. We bundled all our .js files into one static main.js with help of the webpack
module bundler. And even though not required, we decided to give the project one more
glance over and put in some basic CSS styling to pair with the flashy idea of an SPA.

**Limitations:**

There are some limitations to our project, the use of a database for instance, was
recommended but not enforced, and for the scope of the project and considering the
complexity we were already facing in the backend and frontend, we decided not to use
one. Furthermore, we did not end up having time to include an input validation
mechanism for form data, leading to possible inconsistencies in user-entered data.
Nonetheless we did manage to implement a working backend, reinforced by a carefully
integrated frontend SPA.

**Remarks:**

For the first milestone, we were able to follow the example given in the tutorial sessions
to some extent. However, after that we were on our own, since the tutorials
implemented expressJS and ASP.NET, while we were using the Django REST
Framework. Overall, it was a fruitful learning experience.

The documentation in the final submission is altered to reflect the current state of the 
application rather than what we had initially designed. This can be found in the file
api_specification.json in this same directory.
